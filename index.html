<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bad Boys</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --info-bg: #0b1220;
      --info-text: #ffffff;
    }
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:var(--bg); }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg); }
    canvas { width:100%; height:100%; display:block; background:var(--bg); }

    /* TOP CONTROLS - ZOOM AND LOBBY FILTER */
    #top-controls {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    #zoom-controls {
      display: flex;
      gap: 8px;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #494949;
      color: #fff;
      font-size: 14px;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .zoom-btn:hover {
      background: #5a5a5a;
    }
    
    .zoom-btn:active {
      background: #3a3a3a;
    }

    /* LOBBY FILTER */
    #lobby-filter-container {
      position: relative;
    }

    #lobby-filter-btn {
      padding: 6px 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #494949;
      color: #fff;
      font-size: 14px;
      min-width: 120px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      white-space: nowrap;
    }

    #lobby-filter-btn:hover {
      background: #5a5a5a;
    }

    #lobby-filter-btn:active {
      background: #3a3a3a;
    }

    .filter-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--info-bg);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      display: none;
      min-width: 160px;
    }

    .filter-dropdown.open {
      display: block;
    }

    .filter-dropdown label {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      color: #ffffff;
    }

    .filter-dropdown label:hover {
      background: rgba(255,255,255,0.1);
    }

    .filter-dropdown input[type="checkbox"] {
      margin-right: 8px;
    }

    /* INFO PANEL */
    #info-panel {
      width:320px; min-width:260px; max-width:360px;
      background: var(--info-bg); color: var(--info-text);
      padding:12px; box-sizing:border-box;
      display:flex; flex-direction:column;
      border-left: 1px solid rgba(255,255,255,0.04);
      font-size:13px;
      height: 100vh;
      overflow: hidden;
    }
    
    /* WIKIPEDIA PANEL */
    #wiki-panel {
      width:320px; min-width:260px; max-width:360px;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #ccc;
    }

    #wiki-header {
      background: #f8f9fa;
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #wiki-close {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    #wiki-iframe {
      flex: 1;
      border: none;
      width: 100%;
    }

    @media (max-width: 1200px) { 
      #wiki-panel { width: 400px; }
      #wiki-panel.visible ~ #info-panel { display: none; }
    }
    
    #controls { 
      display:flex; 
      gap:8px; 
      align-items:center; 
      flex-shrink: 0; 
      margin-bottom: 8px;
    }
    #search-box { display:flex; width:100%; gap:6px; }
    #search-input { flex:1; padding:6px 8px; border-radius:4px; border:1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); color:inherit; }
    #search-btn, #clear-btn { padding:6px 8px; border-radius:4px; border:none; cursor:pointer; background:#494949; color:#fff; }
    #colorby-select { width:100%; padding:6px 8px; border-radius:4px; border:none; background:#0b1220; color:inherit; }

    #suggestions { background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); max-height:160px; overflow:auto; display:none; padding:6px; border-radius:4px; }
    .suggestion { padding:6px; cursor:pointer; border-bottom:1px dashed rgba(255,255,255,0.03); }
    .suggestion:hover { background: rgba(255,255,255,0.03); }

    #node-info { 
      margin-top:8px; 
      padding:8px; 
      background: rgba(255,255,255,0.02); 
      border-radius:6px; 
      flex-shrink: 0;
    }
    #node-title { font-weight:700; }
    .muted { color:#454545; font-size:13px;  font-weight:700;}

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top:8px;
      background: rgba(255,255,255,0.02);
      border-radius:6px;
      padding:6px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.03);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding:6px;
      cursor:pointer;
      font-size:13px;
      color:var(--info-text);
      border-bottom:1px dashed rgba(255,255,255,0.03);
    }
    .conn-item:hover { background: rgba(255,255,255,0.03); }

    #msg { margin-top:6px; color:#fca5a5; font-size:13px; min-height:18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position:fixed; left:0; top:0; right:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column; gap:10px;
      background: rgba(255,255,255,0.7);
      z-index:99999; /* very high to sit above everything */
      font-size:16px; color:#111827;
    }
    .spinner {
      width:44px; height:44px;
      border-radius:50%;
      border:5px solid rgba(0,0,0,0.08);
      border-left-color:#eb2525;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* responsive */
    @media (max-width: 900px) { #info-panel { width:260px; } }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="top-controls">
        <div id="zoom-controls">
          <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
          <button id="zoom-out" class="zoom-btn" title="Zoom Out">-</button>
          <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">Reset</button>
        </div>
        
        <div id="lobby-filter-container">
          <button id="lobby-filter-btn">
            <span id="lobby-filter-text">Lobbies: All</span>
            <span>▼</span>
          </button>
          <div id="lobby-filter-dropdown" class="filter-dropdown">
            <!-- Dynamically populated -->
          </div>
        </div>
      </div>

      <div id="loading-overlay" aria-hidden="false">
        <div class="spinner" role="img" aria-label="loading"></div>
        <div id="loading-text">This takes a minute...</div>
      </div>
    </div>

      <aside id="info-panel" style="--info-bg:var(--info-bg); --info-text:var(--info-text);">
        <div id="controls">
          <div id="search-box">
            <input id="search-input" placeholder="Search a person or group..." />
            <button id="search-btn">Search</button>
          </div>
        </div>

        <button id="clear-btn" style="margin-bottom: 8px; flex-shrink: 0;">Clear Selection</button>

        <div id="suggestions"></div>

        <div id="node-info">
          <div id="node-title"></div>
          <div id="node-meta" class="muted" style="margin-top:6px;"></div>
        </div>

        <div id="node-links">
          <!-- Wikipedia/Source Watch links will go here -->
        </div>

        <div id="connections-box" aria-live="polite"></div>

        <div id="msg"></div>
      </aside>

      <aside id="wiki-panel">
        <div id="wiki-header">
          <div id="wiki-title">Wikipedia</div>
          <button id="wiki-close">×</button>
        </div>
        <iframe id="wiki-iframe" src="about:blank"></iframe>
      </aside>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    LINKS_CSV: './Bad Boys - LINKSx.csv',
    POINTS_CSV: './Bad Boys - POINTS.csv',

    backgroundColor: '#ffffff',
    defaultPointColor: '#eb2525',
    colorPalette: d3.schemeTableau10,
    pointOpacity: 0.8,
    unconnectedOpacity: 0.18,
    linkColor: '#9ca3af',
    linkOpacityNoSelection: 0.2,
    linkOpacitySelected: 0.5,
    pointStrokeColor: '#ffffff',
    pointStrokeWidth: 1.2,

    // label adjustments (smaller, raised, centered, box opacity 0.5)
    labelFontSize: 13,            // smaller
    labelBoxPadding: 4,
    labelOffsetY: 4,             // raised slightly (smaller value -> closer to node)
    labelBoxOpacity: 0.5,

    // size controls
    sizeByField: 'Size B (%)',
    sizeMin: 0.2,
    sizeMax: 30,
    sizeRangeFactor: 2,

    // force & performance
    force: {
      linkDistance: 50,
      linkStrength: 2.0,
      chargeStrength: -100,
      collisionPadding: 2.5,
      velocityDecay: 0.3
    },

    // pre-tick strategy
    preTickSmall: 400,
    preTickMedium: 160,
    preTickLarge: 105,

    // stability detection / timeouts
    velThreshold: 0.035,
    stableTicksNeeded: 24,
    maxLoadingSeconds: 24,

    showImages: true,
    maxSuggestions: 12,
    
    // zoom settings
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2
  };
  /************************************************************************
   * END CONFIG
   ************************************************************************/
  
  const PADDING = 80; // space from canvas edges

  // UI vars
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  // Zoom and Pan state
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;
  
  // Pan state
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;  // 2 = 2Ã— the device's own pixels
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    ctx.setTransform(hiResScale, 0, 0, hiResScale, 0, 0);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener('resize', () => { resizeCanvas(); if (simulation && simulation.force) { const c = simulation.force('center'); if (c) c.x = (canvas.width/devicePixelRatio)/2, c.y = (canvas.height/devicePixelRatio)/2; } });
  resizeCanvas();

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');

  // Zoom control elements
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');

  // Lobby filter elements
  const lobbyFilterBtn = document.getElementById('lobby-filter-btn');
  const lobbyFilterText = document.getElementById('lobby-filter-text');
  const lobbyFilterDropdown = document.getElementById('lobby-filter-dropdown');

  // Wikipedia panel elements
  const wikiPanel = document.getElementById('wiki-panel');
  const wikiTitle = document.getElementById('wiki-title');
  const wikiIframe = document.getElementById('wiki-iframe');
  const wikiClose = document.getElementById('wiki-close');

  // data state
  let nodes = [];
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let isStable = false;
  let imageLoadPromises = [];
  const categoricalColor = d3.scaleOrdinal(CONFIG.colorPalette);

  // Lobby filter state
  let selectedLobbies = new Set(['All']);
  let lobbyColumns = [];
  let nodeLobbies = new Map();

  // Zoom control functions
  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  function updateCanvasCursor() {
    if (isDragging) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  // Zoom control event listeners
  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);

  function extractLobbyColumns(rawPoints) {
    const lobbyColumns = [];
    const sampleRow = rawPoints[0] || {};
    
    Object.keys(sampleRow).forEach(columnName => {
      if (columnName.includes(' Lobby Member')) {
        const lobbyName = columnName.replace(' Lobby Member', '').trim();
        lobbyColumns.push({
          displayName: lobbyName,
          columnName: columnName
        });
      }
    });
    
    return lobbyColumns.sort((a, b) => a.displayName.localeCompare(b.displayName));
  }

  function buildNodeLobbies(nodes, lobbyColumns) {
    const nodeLobbies = new Map();
    
    nodes.forEach(node => {
      const lobbies = [];
      lobbyColumns.forEach(lobby => {
        const value = node.raw[lobby.columnName];
        if (value === '1' || value === 1 || value === true) {
          lobbies.push(lobby.displayName);
        }
      });
      nodeLobbies.set(node.id, lobbies);
    });
    
    return nodeLobbies;
  }

  function initializeLobbyFilter() {
    // Populate dropdown
    let html = '<label><input type="checkbox" value="All" checked> All</label>';
    lobbyColumns.forEach(lobby => {
      html += `<label><input type="checkbox" value="${lobby.displayName}"> ${lobby.displayName}</label>`;
    });
    lobbyFilterDropdown.innerHTML = html;
    
    // Add event listeners
    lobbyFilterDropdown.addEventListener('change', onLobbyCheckboxChange);
    lobbyFilterBtn.addEventListener('click', toggleLobbyDropdown);
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!lobbyFilterBtn.contains(e.target) && !lobbyFilterDropdown.contains(e.target)) {
        lobbyFilterDropdown.classList.remove('open');
      }
    });
  }

  function toggleLobbyDropdown() {
    lobbyFilterDropdown.classList.toggle('open');
  }

  function onLobbyCheckboxChange(e) {
    const checkbox = e.target;
    const value = checkbox.value;
    
    if (value === 'All') {
      if (checkbox.checked) {
        selectedLobbies.clear();
        selectedLobbies.add('All');
        // Uncheck all others
        lobbyFilterDropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          if (cb.value !== 'All') cb.checked = false;
        });
      }
    } else {
      if (checkbox.checked) {
        selectedLobbies.delete('All');
        selectedLobbies.add(value);
        // Uncheck "All"
        lobbyFilterDropdown.querySelector('input[value="All"]').checked = false;
      } else {
        selectedLobbies.delete(value);
        // If nothing selected, default to "All"
        if (selectedLobbies.size === 0) {
          selectedLobbies.add('All');
          lobbyFilterDropdown.querySelector('input[value="All"]').checked = true;
        }
      }
    }
    
    updateLobbyFilterText();
    render();
  }

  function updateLobbyFilterText() {
    if (selectedLobbies.has('All')) {
      lobbyFilterText.textContent = 'Lobbies: All';
    } else {
      const lobbies = Array.from(selectedLobbies);
      if (lobbies.length <= 2) {
        lobbyFilterText.textContent = `Lobbies: ${lobbies.join(', ')}`;
      } else {
        lobbyFilterText.textContent = `Lobbies: ${lobbies.length} selected`;
      }
    }
  }

  function resetLobbyFilter() {
    selectedLobbies.clear();
    selectedLobbies.add('All');
    lobbyFilterDropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.checked = cb.value === 'All';
    });
    updateLobbyFilterText();
  }

  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function computePreTicks(nCount) {
    if (nCount <= 500) return CONFIG.preTickSmall;
    if (nCount <= 2000) return CONFIG.preTickMedium;
    return CONFIG.preTickLarge;
  }

  function showWikipediaPanel(url, nodeName) {
    if (!url) return;
    wikiTitle.textContent = `Wikipedia: ${nodeName}`;
    wikiIframe.src = url;
  }

  function hideWikipediaPanel() {
    wikiTitle.textContent = 'Wikipedia';
    wikiIframe.src = 'about:blank';
  }

  // Event listener
  wikiClose.addEventListener('click', hideWikipediaPanel);

  // Show loading overlay immediately
  loadingOverlay.style.display = 'flex';

  requestAnimationFrame(() => {
    Promise.all([ d3.csv(CONFIG.LINKS_CSV), d3.csv(CONFIG.POINTS_CSV) ])
      .then(([rawLinks, rawPoints]) => {
        // normalize keys
        rawPoints.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });
        rawLinks.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });

        // Extract lobby columns BEFORE building nodes
        lobbyColumns = extractLobbyColumns(rawPoints);

        // build nodes
        nodes = rawPoints.map((d,i) => {
          const id = d['Thing'] ? String(d['Thing']).trim() : `__P_${i}`;
          const rawSize = (d[CONFIG.sizeByField] || '').toString().replace('%','').trim();
          const sizeVal = parseFloat(rawSize) || 0;
          return {
            id, name: id, raw: d, sizeVal,
            image: d['Image'] ? d['Image'].trim() : null, imageBitmap: null,
            x: Math.random() * (canvas.width/devicePixelRatio), y: Math.random() * (canvas.height/devicePixelRatio),
            vx: 0, vy: 0, r: CONFIG.sizeMin
          };
        });

        nodeById = new Map(nodes.map(n => [n.id, n]));

        // build temporary links
        const tmpLinks = (rawLinks || []).map(r => ({
          sourceName: (r['A']||'').toString().trim(),
          targetName: (r['B']||'').toString().trim(),
          value: +((r['Link Size']||r['LinkSize']) || 1) || 1
        })).filter(l => l.sourceName && l.targetName);

        tmpLinks.forEach(l => {
          if (!nodeById.has(l.sourceName)) {
            const n = { id: l.sourceName, name: l.sourceName, raw: {}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
          if (!nodeById.has(l.targetName)) {
            const n = { id: l.targetName, name: l.targetName, raw:{}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
        });

        links = tmpLinks.map(l => ({ source: nodeById.get(l.sourceName), target: nodeById.get(l.targetName), value: l.value })).filter(l => l.source && l.target);

        // compute radii and increase dynamic range
        const vals = nodes.map(n => n.sizeVal || 0);
        const vmin = d3.min(vals) || 0;
        const vmax = d3.max(vals) || 1;
        const baseScale = d3.scaleSqrt().domain([vmin, vmax]).range([CONFIG.sizeMin, CONFIG.sizeMax]);
        nodes.forEach(n => {
          const base = baseScale(n.sizeVal || 0);
          const r = CONFIG.sizeMin + (base - CONFIG.sizeMin) * CONFIG.sizeRangeFactor;
          n.r = Math.max(CONFIG.sizeMin, Math.min(r, CONFIG.sizeMax * CONFIG.sizeRangeFactor * 1.5));
        });

        // adjacency
        adjacency = new Map(); nodes.forEach(n => adjacency.set(n.id, new Set()));
        links.forEach(l => {
          adjacency.get(l.source.id).add(l.target.id);
          adjacency.get(l.target.id).add(l.source.id);
        });

        nameIndex = nodes.map(n => n.name);

        // Build lobby mappings AFTER nodes are created
        nodeLobbies = buildNodeLobbies(nodes, lobbyColumns);

        // link width scale
        const linkValues = links.map(l => l.value || 1);
        const linkWidthScale = d3.scaleLinear().domain([d3.min(linkValues) || 1, d3.max(linkValues) || 1]).range([0.6, 4]).clamp(true);
        window.__linkWidthScale = linkWidthScale;

        // Initialize lobby filter UI
        if (lobbyColumns.length > 0) {
          initializeLobbyFilter();
        } else {
          // Hide lobby filter if no lobby columns found
          document.getElementById('lobby-filter-container').style.display = 'none';
        }

        // preload images using fetch + createImageBitmap where available for faster decoding.
        const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
        imageLoadPromises = imgNodes.map(n => {
          return new Promise(async resolve => {
            try {
              // Attempt fetch -> blob -> createImageBitmap (fast, off-main-thread in browsers that support it)
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 7000);
              const resp = await fetch(n.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
              clearTimeout(timeoutId);
              if (!resp || !resp.ok) throw new Error('fetch failed');
              const blob = await resp.blob();
              // prefer createImageBitmap
              if (typeof createImageBitmap === 'function') {
                try {
                  const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
                  n.imageBitmap = bmp;
                  resolve({n,ok:true});
                  return;
                } catch (e) {
                  // fallback to image element below
                }
              }
              // fallback: use Image element
              const img = new Image();
              img.onload = () => { n.imageBitmap = img; resolve({n,ok:true}); };
              img.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
              img.src = URL.createObjectURL(blob);
              // safety timeout
              setTimeout(() => { if (!n.imageBitmap) { n.imageBitmap = null; resolve({n,ok:false}); } }, 7000);
            } catch (err) {
              // fallback to Image() with original URL (no CORS guarantee)
              try {
                const img2 = new Image();
                img2.onload = () => { n.imageBitmap = img2; resolve({n,ok:true}); };
                img2.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
                img2.src = n.image;
                setTimeout(() => { if (!n.imageBitmap) resolve({n,ok:false}); }, 7000);
              } catch (e) {
                n.imageBitmap = null;
                resolve({n,ok:false});
              }
            }
          });
        });

        // create simulation
        simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id)
            .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
            .strength(CONFIG.force.linkStrength))
          .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
          .force('center', d3.forceCenter((canvas.width/devicePixelRatio)/2, (canvas.height/devicePixelRatio)/2))
          .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
          .velocityDecay(CONFIG.force.velocityDecay);

        // pre-tick synchronously
        const preTicks = computePreTicks(nodes.length);
        simulation.stop();
        for (let i=0;i<preTicks;i++) simulation.tick();

        // now draw initial state and start asynchronous ticks
        render();

        // stability detection
        let stableCount = 0;
        const velThreshold = CONFIG.velThreshold;
        const stableNeeded = CONFIG.stableTicksNeeded;
        const startTime = Date.now();
        let forcedHideTimer = setTimeout(() => {
          if (!isStable) {
            if (simulation) simulation.stop();
            isStable = true;
            hideLoadingOverlay();
            render(); // final draw
          }
        }, CONFIG.maxLoadingSeconds * 1000);

        simulation.on('tick', () => {
          nodes.forEach(n => {
            n.x = Math.max(n.r + PADDING, Math.min((canvas.width/devicePixelRatio) - n.r - PADDING, n.x));
            n.y = Math.max(n.r + PADDING, Math.min((canvas.height/devicePixelRatio) - n.r - PADDING, n.y));
          });


          let maxSpeed = 0;
          for (const n of nodes) {
            const speed = Math.hypot(n.vx||0, n.vy||0);
            if (speed > maxSpeed) maxSpeed = speed;
          }

          if (maxSpeed < velThreshold) stableCount++; else stableCount = 0;
          render();

          if (!isStable && stableCount >= stableNeeded) {
            isStable = true;
            simulation.stop();
            hideLoadingOverlay();
            clearTimeout(forcedHideTimer);
          }
        });

        simulation.alpha(0.3).restart();

        // when images finish (or time out), redraw to show them
        Promise.allSettled(imageLoadPromises).then(() => { render(); });

      }).catch(err => {
        console.error('CSV load error', err);
        loadingText.textContent = 'Failed to load CSV files — check paths and console.';
        setTimeout(() => { loadingOverlay.style.display = 'none'; }, 8000);
      });
  });

  /************************************************************************
   * Drawing utilities
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = CONFIG.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
  }

  function applyTransform() {
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = (window.__linkWidthScale ? window.__linkWidthScale(l.value) : 1) / zoomLevel;
    ctx.strokeStyle = CONFIG.linkColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    ctx.globalAlpha = opacity;
    const x = n.x, y = n.y, r = n.r;

    // Draw image if available (cover behavior)
    if (showImage && n.imageBitmap) {
      // clip to circle
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      // draw image centered and scaled (cover)
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      // If imageBitmap is a ImageBitmap or Image element, draw it directly.
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high'; // 'medium' or 'low' are defaults
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        // fallback: fill with color
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = getNodeFill(n);
        ctx.fill();
      }
      ctx.restore();
      ctx.save();
    } else {
      // fill circle with color
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = getNodeFill(n);
      ctx.fill();
    }

    // stroke
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = CONFIG.pointStrokeWidth / zoomLevel;
    ctx.strokeStyle = CONFIG.pointStrokeColor;
    ctx.stroke();

    ctx.restore();
  }

  // draw label box centered under node; text centered inside; raised slightly; smaller font; box opacity 0.5
  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px ${CONFIG.labelTextFont || 'Arial, sans-serif'}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    // box with 0.5 opacity
    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    // text (full opacity)
    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function getNodeFill(n) {
    return CONFIG.defaultPointColor;
  }

  /************************************************************************
   * Render logic (ensures links appear on top of unconnected nodes)
   ************************************************************************/
  function shouldHighlightNode(node) {
    // Check lobby filter first
    let matchesLobby = true;
    if (!selectedLobbies.has('All')) {
      const nodeLobbyList = nodeLobbies.get(node.id) || [];
      matchesLobby = nodeLobbyList.some(lobby => selectedLobbies.has(lobby));
    }
    
    // Check connection filter
    const activeNode = selectedNode;
    let matchesConnection = true;
    if (activeNode) {
      const activeSet = new Set([activeNode.id, ...(adjacency.get(activeNode.id) || [])]);
      matchesConnection = activeSet.has(node.id);
    }
    
    return matchesLobby && matchesConnection;
  }

  function render() {
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    const activeNode = selectedNode;
    
    // Separate nodes into highlighted and unhighlighted
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    nodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    // Draw unhighlighted nodes first (behind)
    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    // Draw links between highlighted nodes
    if (activeNode) {
      const highlightedSet = new Set(highlightedNodes.map(n => n.id));
      links.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      // No selection: show all links between highlighted nodes
      const highlightedSet = new Set(highlightedNodes.map(n => n.id));
      links.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacityNoSelection);
        }
      });
    }

    // Draw highlighted nodes on top
    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    // Draw labels for highlighted nodes (if selection exists)
    if (activeNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(activeNode.id).has(n.id) || n === activeNode) {
          drawLabel(n);
        }
      });
    }

    ctx.restore();
  }

  /************************************************************************
   * Mouse interaction with pan and zoom support
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / devicePixelRatio) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / devicePixelRatio) / rect.height;
    
    // Transform coordinates to account for zoom and pan
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    // prefer active nodes first when selected
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = nodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = nodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  // Mouse event handlers for panning (only when zoomed in) and clicking
  canvas.addEventListener('mousedown', (evt) => {
    if (zoomLevel <= 1.0) return; // Only allow panning when zoomed in
    
    isDragging = true;
    updateCanvasCursor();
    
    dragStartX = evt.clientX;
    dragStartY = evt.clientY;
    dragStartPanX = panX;
    dragStartPanY = panY;
    
    evt.preventDefault();
  });

  canvas.addEventListener('mousemove', (evt) => {
    if (!isDragging || zoomLevel <= 1.0) {
      updateCanvasCursor();
      return;
    }
    
    const deltaX = evt.clientX - dragStartX;
    const deltaY = evt.clientY - dragStartY;
    
    panX = dragStartPanX + deltaX / zoomLevel;
    panY = dragStartPanY + deltaY / zoomLevel;
    
    render();
    evt.preventDefault();
  });

  canvas.addEventListener('mouseup', (evt) => {
    if (isDragging) {
      // Check if we actually moved (to distinguish from clicks)
      const deltaX = Math.abs(evt.clientX - dragStartX);
      const deltaY = Math.abs(evt.clientY - dragStartY);
      
      isDragging = false;
      updateCanvasCursor();
      
      // If movement was minimal, treat as click for node selection
      if (deltaX < 3 && deltaY < 3) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          // Check if clicked node matches current lobby filter
          if (!selectedLobbies.has('All')) {
            const nodeLobbyList = nodeLobbies.get(n.id) || [];
            const nodeMatchesFilter = nodeLobbyList.some(lobby => selectedLobbies.has(lobby));
            
            if (!nodeMatchesFilter) {
              resetLobbyFilter();
            }
          }
          
          selectedNode = n;
          populateInfoPanel(n);
          render();
        } else {
          selectedNode = null;
          clearInfoPanel();
          render();
        }
      }
      evt.preventDefault();
    }
  });

  // Handle clicks when not zoomed in (original click behavior)
  canvas.addEventListener('click', (evt) => {
    // Only handle clicks when not zoomed in or when we weren't dragging
    if (zoomLevel > 1.0 || isDragging) return;
    
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      // Check if clicked node matches current lobby filter
      if (!selectedLobbies.has('All')) {
        const nodeLobbyList = nodeLobbies.get(n.id) || [];
        const nodeMatchesFilter = nodeLobbyList.some(lobby => selectedLobbies.has(lobby));
        
        if (!nodeMatchesFilter) {
          resetLobbyFilter();
        }
      }
      
      selectedNode = n;
      populateInfoPanel(n);
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    isDragging = false;
    updateCanvasCursor();
  });

  /************************************************************************
   * Info panel: populate and connections listing (alphabetical, clickable)
   ************************************************************************/
  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const lobby = (d.raw && (d.raw['Lobby'] || '')) || '';

    // name in larger font, description below
    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:1400;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
    `);

    nodeMetaEl.html(lobby.replace(/\n/g, '<br>'));
    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawLobbyLink = (d.raw && (d.raw['Sourcewatch'] || d.raw['Sourcewatch'])) || '';
    const safeLobby = normalizeUrl(rawLobbyLink);

    let links = [];
    if (safe)      links.push(`<a href="${safe}" target="_blank" rel="noopener">Wikipedia</a>`);
    if (safeLobby) links.push(`<a href="${safeLobby}" target="_blank" rel="noopener">Source Watch</a>`);
    nodeLinkEl.html(links.join(' | '));

    // Auto-show Wikipedia panel if there's a Wikipedia link
    if (safe) {
      showWikipediaPanel(safe, d.name);
    }

    // connections list: gather neighbor names, sort alphabetically, display in scroll box
    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    // clear box
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.textContent = name;
      item.addEventListener('click', () => {
        // selecting a connection by name: find node and select it
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          render();
          // scroll connections box to top to show new list
          connectionsBox.scrollTop = 0;
        }
      });
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.text('');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
    hideWikipediaPanel();
  }

  /************************************************************************
   * Search & suggestions
   ************************************************************************/
  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { performSearch(searchInput.value.trim()); ev.preventDefault(); } });

  clearBtn.addEventListener('click', () => { 
    selectedNode = null; 
    clearInfoPanel(); 
    resetLobbyFilter();
    render(); 
    searchInput.value = ''; 
    suggestionsEl.style('display', 'none').html(''); 
    msgEl.text('');
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; populateInfoPanel(exact); render(); d3.select('#msg').text(''); return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; populateInfoPanel(matches[0]); render(); d3.select('#msg').text(''); return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          render();
        });
      });
      d3.select('#msg').text('Multiple matches — click a suggestion.'); return;
    } else {
      d3.select('#msg').text('Search term not found. Please try again.');
    }
  }

  function hideLoadingOverlay() { loadingOverlay.style.display = 'none'; }

  // Safety fallback: ensure overlay never permanently hangs
  setTimeout(() => {
    if (!isStable) {
      if (simulation) simulation.stop();
      isStable = true;
      hideLoadingOverlay();
      render();
    }
  }, (CONFIG.maxLoadingSeconds + 3) * 1000);

  // expose minimal debug
  window.__fdg = { nodes, links, CONFIG, render, zoomLevel, panX, panY };
  </script>
</body>
</html>