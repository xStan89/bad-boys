<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bad Boys — Force-Directed Graph (Canvas, Click-only)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --info-bg: #0b1220;
      --info-text: #ffffff;
    }
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:var(--bg); }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg); }
    canvas { width:100%; height:100%; display:block; background:var(--bg); }

    /* INFO PANEL */
    #info-panel {
      width:320px; min-width:260px; max-width:360px;
      background: var(--info-bg); color: var(--info-text);
      padding:12px; box-sizing:border-box;
      display:flex; flex-direction:column; gap:8px;
      border-left: 1px solid rgba(255,255,255,0.04);
      font-size:13px;
    }
    #controls { display:flex; gap:8px; align-items:center; }
    #search-box { display:flex; width:100%; gap:6px; }
    #search-input { flex:1; padding:6px 8px; border-radius:4px; border:1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); color:inherit; }
    #search-btn, #clear-btn { padding:6px 8px; border-radius:4px; border:none; cursor:pointer; background:#494949; color:#fff; }
    #colorby-select { width:100%; padding:6px 8px; border-radius:4px; border:none; background:#0b1220; color:inherit; }

    #suggestions { background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); max-height:160px; overflow:auto; display:none; padding:6px; border-radius:4px; }
    .suggestion { padding:6px; cursor:pointer; border-bottom:1px dashed rgba(255,255,255,0.03); }
    .suggestion:hover { background: rgba(255,255,255,0.03); }

    #node-info { margin-top:6px; padding:8px; background: rgba(255,255,255,0.02); border-radius:6px; min-height:64px; }
    #node-title { font-weight:700; }
    .muted { color:#454545; font-size:13px;  font-weight:700;}

    #connections-box {
      margin-top:8px;
      background: rgba(255,255,255,0.02);
      border-radius:6px;
      padding:6px;
      max-height:400px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .conn-item {
      padding:6px;
      cursor:pointer;
      font-size:13px;
      color:var(--info-text);
      border-bottom:1px dashed rgba(255,255,255,0.03);
    }
    .conn-item:hover { background: rgba(255,255,255,0.03); }

    #msg { margin-top:6px; color:#fca5a5; font-size:13px; min-height:18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position:fixed; left:0; top:0; right:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column; gap:10px;
      background: rgba(255,255,255,0.7);
      z-index:99999; /* very high to sit above everything */
      font-size:16px; color:#111827;
    }
    .spinner {
      width:44px; height:44px;
      border-radius:50%;
      border:5px solid rgba(0,0,0,0.08);
      border-left-color:#eb2525;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* responsive */
    @media (max-width: 900px) { #info-panel { width:260px; } }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="graph-area">
      <canvas id="canvas"></canvas>

      <div id="loading-overlay" aria-hidden="false">
        <div class="spinner" role="img" aria-label="loading"></div>
        <div id="loading-text">This takes a minute...</div>
      </div>
    </div>

    <aside id="info-panel" style="--info-bg:var(--info-bg); --info-text:var(--info-text);">
      <div id="controls">
        <div id="search-box">
          <input id="search-input" placeholder="Search a person or group..." />
          <button id="search-btn">Search</button>
        </div>
      </div>

      <button id="clear-btn">Clear Selection</button>

      <div id="suggestions"></div>

      <div id="node-info">
        <div id="node-title"></div>
        <div id="node-meta" class="muted" style="margin-top:6px;"></div>
        <div id="node-link" style="margin-top:8px;"></div>
      </div>

      <div id="connections-box" aria-live="polite"></div>

      <div id="msg"></div>
    </aside>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    LINKS_CSV: './Bad Boys - LINKSx.csv',
    POINTS_CSV: './Bad Boys - POINTS.csv',

    backgroundColor: '#ffffff',
    defaultPointColor: '#eb2525',
    colorPalette: d3.schemeTableau10,
    pointOpacity: 0.8,
    unconnectedOpacity: 0.28,
    linkColor: '#9ca3af',
    linkOpacityNoSelection: 0.2,
    linkOpacitySelected: 0.5,
    pointStrokeColor: '#ffffff',
    pointStrokeWidth: 1.2,

    // label adjustments (smaller, raised, centered, box opacity 0.5)
    labelFontSize: 11,            // smaller
    labelBoxPadding: 6,
    labelOffsetY: 4,             // raised slightly (smaller value -> closer to node)
    labelBoxOpacity: 0.5,

    // size controls
    sizeByField: 'Size B (%)',
    sizeMin: 1,
    sizeMax: 15,
    sizeRangeFactor: 3,

    // force & performance
    force: {
      linkDistance: 90,
      linkStrength: 1.0,
      chargeStrength: -30,
      collisionPadding: 2,
      velocityDecay: 0.4
    },

    // pre-tick strategy
    preTickSmall: 400,
    preTickMedium: 160,
    preTickLarge: 105,

    // stability detection / timeouts
    velThreshold: 0.035,
    stableTicksNeeded: 24,
    maxLoadingSeconds: 24,

    showImages: true,
    maxSuggestions: 12
  };
  /************************************************************************
   * END CONFIG
   ************************************************************************/
  
  const PADDING = 60; // space from canvas edges

  // UI vars
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(600, Math.floor(rect.width * devicePixelRatio));
    canvas.height = Math.max(400, Math.floor(rect.height * devicePixelRatio));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener('resize', () => { resizeCanvas(); if (simulation && simulation.force) { const c = simulation.force('center'); if (c) c.x = (canvas.width/devicePixelRatio)/2, c.y = (canvas.height/devicePixelRatio)/2; } });
  resizeCanvas();

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-link');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');

  // data state
  let nodes = [];
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let isStable = false;
  let imageLoadPromises = [];
  const categoricalColor = d3.scaleOrdinal(CONFIG.colorPalette);

  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function computePreTicks(nCount) {
    if (nCount <= 500) return CONFIG.preTickSmall;
    if (nCount <= 2000) return CONFIG.preTickMedium;
    return CONFIG.preTickLarge;
  }

  // Show loading overlay immediately
  loadingOverlay.style.display = 'flex';

  requestAnimationFrame(() => {
    Promise.all([ d3.csv(CONFIG.LINKS_CSV), d3.csv(CONFIG.POINTS_CSV) ])
      .then(([rawLinks, rawPoints]) => {
        // normalize keys
        rawPoints.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });
        rawLinks.forEach(r => { Object.keys(r).forEach(k => { if (k !== k.trim()) { r[k.trim()] = r[k]; delete r[k]; } }); });

        // build nodes
        nodes = rawPoints.map((d,i) => {
          const id = d['Thing'] ? String(d['Thing']).trim() : `__P_${i}`;
          const rawSize = (d[CONFIG.sizeByField] || '').toString().replace('%','').trim();
          const sizeVal = parseFloat(rawSize) || 0;
          return {
            id, name: id, raw: d, sizeVal,
            image: d['Image'] ? d['Image'].trim() : null, imageBitmap: null,
            x: Math.random() * (canvas.width/devicePixelRatio), y: Math.random() * (canvas.height/devicePixelRatio),
            vx: 0, vy: 0, r: CONFIG.sizeMin
          };
        });

        nodeById = new Map(nodes.map(n => [n.id, n]));

        // build temporary links
        const tmpLinks = (rawLinks || []).map(r => ({
          sourceName: (r['A']||'').toString().trim(),
          targetName: (r['B']||'').toString().trim(),
          value: +((r['Link Size']||r['LinkSize']) || 1) || 1
        })).filter(l => l.sourceName && l.targetName);

        tmpLinks.forEach(l => {
          if (!nodeById.has(l.sourceName)) {
            const n = { id: l.sourceName, name: l.sourceName, raw: {}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
          if (!nodeById.has(l.targetName)) {
            const n = { id: l.targetName, name: l.targetName, raw:{}, sizeVal:0, image:null, imageBitmap:null, x:Math.random()*canvas.width, y:Math.random()*canvas.height, vx:0, vy:0, r:CONFIG.sizeMin };
            nodes.push(n); nodeById.set(n.id, n);
          }
        });

        links = tmpLinks.map(l => ({ source: nodeById.get(l.sourceName), target: nodeById.get(l.targetName), value: l.value })).filter(l => l.source && l.target);

        // compute radii and increase dynamic range
        const vals = nodes.map(n => n.sizeVal || 0);
        const vmin = d3.min(vals) || 0;
        const vmax = d3.max(vals) || 1;
        const baseScale = d3.scaleSqrt().domain([vmin, vmax]).range([CONFIG.sizeMin, CONFIG.sizeMax]);
        nodes.forEach(n => {
          const base = baseScale(n.sizeVal || 0);
          const r = CONFIG.sizeMin + (base - CONFIG.sizeMin) * CONFIG.sizeRangeFactor;
          n.r = Math.max(CONFIG.sizeMin, Math.min(r, CONFIG.sizeMax * CONFIG.sizeRangeFactor * 1.5));
        });

        // adjacency
        adjacency = new Map(); nodes.forEach(n => adjacency.set(n.id, new Set()));
        links.forEach(l => {
          adjacency.get(l.source.id).add(l.target.id);
          adjacency.get(l.target.id).add(l.source.id);
        });

        nameIndex = nodes.map(n => n.name);

        // link width scale
        const linkValues = links.map(l => l.value || 1);
        const linkWidthScale = d3.scaleLinear().domain([d3.min(linkValues) || 1, d3.max(linkValues) || 1]).range([0.6, 4]).clamp(true);
        window.__linkWidthScale = linkWidthScale;

        // preload images using fetch + createImageBitmap where available for faster decoding.
        const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
        imageLoadPromises = imgNodes.map(n => {
          return new Promise(async resolve => {
            try {
              // Attempt fetch -> blob -> createImageBitmap (fast, off-main-thread in browsers that support it)
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 7000);
              const resp = await fetch(n.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
              clearTimeout(timeoutId);
              if (!resp || !resp.ok) throw new Error('fetch failed');
              const blob = await resp.blob();
              // prefer createImageBitmap
              if (typeof createImageBitmap === 'function') {
                try {
                  const bmp = await createImageBitmap(blob);
                  n.imageBitmap = bmp;
                  resolve({n,ok:true});
                  return;
                } catch (e) {
                  // fallback to image element below
                }
              }
              // fallback: use Image element
              const img = new Image();
              img.onload = () => { n.imageBitmap = img; resolve({n,ok:true}); };
              img.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
              img.src = URL.createObjectURL(blob);
              // safety timeout
              setTimeout(() => { if (!n.imageBitmap) { n.imageBitmap = null; resolve({n,ok:false}); } }, 7000);
            } catch (err) {
              // fallback to Image() with original URL (no CORS guarantee)
              try {
                const img2 = new Image();
                img2.onload = () => { n.imageBitmap = img2; resolve({n,ok:true}); };
                img2.onerror = () => { n.imageBitmap = null; resolve({n,ok:false}); };
                img2.src = n.image;
                setTimeout(() => { if (!n.imageBitmap) resolve({n,ok:false}); }, 7000);
              } catch (e) {
                n.imageBitmap = null;
                resolve({n,ok:false});
              }
            }
          });
        });

        // create simulation
        simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id)
            .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
            .strength(CONFIG.force.linkStrength))
          .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
          .force('center', d3.forceCenter((canvas.width/devicePixelRatio)/2, (canvas.height/devicePixelRatio)/2))
          .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
          .velocityDecay(CONFIG.force.velocityDecay);

        // pre-tick synchronously
        const preTicks = computePreTicks(nodes.length);
        simulation.stop();
        for (let i=0;i<preTicks;i++) simulation.tick();

        // now draw initial state and start asynchronous ticks
        render();

        // stability detection
        let stableCount = 0;
        const velThreshold = CONFIG.velThreshold;
        const stableNeeded = CONFIG.stableTicksNeeded;
        const startTime = Date.now();
        let forcedHideTimer = setTimeout(() => {
          if (!isStable) {
            if (simulation) simulation.stop();
            isStable = true;
            hideLoadingOverlay();
            render(); // final draw
          }
        }, CONFIG.maxLoadingSeconds * 1000);

        simulation.on('tick', () => {
          nodes.forEach(n => {
            n.x = Math.max(n.r + PADDING, Math.min((canvas.width/devicePixelRatio) - n.r - PADDING, n.x));
            n.y = Math.max(n.r + PADDING, Math.min((canvas.height/devicePixelRatio) - n.r - PADDING, n.y));
          });


          let maxSpeed = 0;
          for (const n of nodes) {
            const speed = Math.hypot(n.vx||0, n.vy||0);
            if (speed > maxSpeed) maxSpeed = speed;
          }

          if (maxSpeed < velThreshold) stableCount++; else stableCount = 0;
          render();

          if (!isStable && stableCount >= stableNeeded) {
            isStable = true;
            simulation.stop();
            hideLoadingOverlay();
            clearTimeout(forcedHideTimer);
          }
        });

        simulation.alpha(0.3).restart();

        // when images finish (or time out), redraw to show them
        Promise.allSettled(imageLoadPromises).then(() => { render(); });

      }).catch(err => {
        console.error('CSV load error', err);
        loadingText.textContent = 'Failed to load CSV files — check paths and console.';
        setTimeout(() => { loadingOverlay.style.display = 'none'; }, 8000);
      });
  });

  /************************************************************************
   * Drawing utilities
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = CONFIG.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = (window.__linkWidthScale ? window.__linkWidthScale(l.value) : 1);
    ctx.strokeStyle = CONFIG.linkColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    ctx.globalAlpha = opacity;
    const x = n.x, y = n.y, r = n.r;

    // Draw image if available (cover behavior)
    if (showImage && n.imageBitmap) {
      // clip to circle
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      // draw image centered and scaled (cover)
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      // If imageBitmap is a ImageBitmap or Image element, draw it directly.
      try {
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        // fallback: fill with color
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = getNodeFill(n);
        ctx.fill();
      }
      ctx.restore();
      ctx.save();
    } else {
      // fill circle with color
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = getNodeFill(n);
      ctx.fill();
    }

    // stroke
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = CONFIG.pointStrokeWidth;
    ctx.strokeStyle = CONFIG.pointStrokeColor;
    ctx.stroke();

    ctx.restore();
  }

  // draw label box centered under node; text centered inside; raised slightly; smaller font; box opacity 0.5
  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize}px ${CONFIG.labelTextFont || 'Arial, sans-serif'}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding;
    const boxW = textW + pad * 2;
    const boxH = CONFIG.labelFontSize + 6;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY;

    // box with 0.5 opacity
    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6);
    ctx.fill();
    ctx.restore();

    // text (full opacity)
    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function getNodeFill(n) {
    return CONFIG.defaultPointColor;
  }

  /************************************************************************
   * Render logic (ensures links appear on top of unconnected nodes)
   ************************************************************************/
  function render() {
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    const activeNode = selectedNode;
    const activeSet = new Set();
    if (activeNode) {
      activeSet.add(activeNode.id);
      (adjacency.get(activeNode.id) || []).forEach(nb => activeSet.add(nb));
    }

    // No selection: links behind nodes
    if (!activeNode) {
      // links first (behind)
      for (const l of links) drawLink(l, CONFIG.linkOpacityNoSelection);
      // then all nodes on top
      for (const n of nodes) drawNode(n, CONFIG.pointOpacity, CONFIG.showImages);
      // no labels when no selection
      return;
    }

    // Selection: drawing order must be:
    // 1) unconnected nodes (behind)
    // 2) links (only those connecting active nodes) — must be on top of unconnected nodes
    // 3) connected nodes (active set) on top of links
    // 4) labels for active nodes
    // We must ensure links render after unconnected nodes (so they appear on top of them)

    // 1) unconnected nodes
    for (const n of nodes) {
      if (!activeSet.has(n.id)) drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages);
    }

    // 2) links among active nodes (draw on top of unconnected nodes)
    for (const l of links) {
      if (activeSet.has(l.source.id) && activeSet.has(l.target.id)) {
        drawLink(l, CONFIG.linkOpacitySelected);
      }
    }

    // 3) connected nodes on top
    for (const n of nodes) {
      if (activeSet.has(n.id)) drawNode(n, CONFIG.pointOpacity, CONFIG.showImages);
    }

    // 4) labels for active nodes (slightly raised, smaller, centered)
    for (const n of nodes) {
      if (activeSet.has(n.id)) drawLabel(n);
    }
  }

  /************************************************************************
   * Click-only selection (no hover)
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / devicePixelRatio) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / devicePixelRatio) / rect.height;
    return { x, y };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    // prefer active nodes first when selected
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = nodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = nodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  canvas.addEventListener('click', (evt) => {
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      populateInfoPanel(n);
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      render();
    }
  });

  /************************************************************************
   * Info panel: populate and connections listing (alphabetical, clickable)
   ************************************************************************/
  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const lobby = (d.raw && (d.raw['Lobby'] || '')) || '';

    // name in larger font, description below
    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:1400;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
    `);

    nodeMetaEl.html(`${lobby}`);
    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawLobbyLink = (d.raw && (d.raw['Sourcewatch'] || d.raw['Sourcewatch'])) || '';
    const safeLobby = normalizeUrl(rawLobbyLink);

    let linksHtml = '';
    if (safe)      linksHtml += `<div><a href="${safe}" target="_blank" rel="noopener">Wikipedia</a></div>`;
    if (safeLobby) linksHtml += `<div><a href="${safeLobby}" target="_blank" rel="noopener">Source Watch</a></div>`;
    nodeLinkEl.html(linksHtml);

    // connections list: gather neighbor names, sort alphabetically, display in scroll box
    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    // clear box
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.textContent = name;
      item.addEventListener('click', () => {
        // selecting a connection by name: find node and select it
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          render();
          // scroll connections box to top to show new list
          connectionsBox.scrollTop = 0;
        }
      });
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.text('');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
  }

  /************************************************************************
   * Search & suggestions
   ************************************************************************/
  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { performSearch(searchInput.value.trim()); ev.preventDefault(); } });

  clearBtn.addEventListener('click', () => { selectedNode = null; clearInfoPanel(); render(); });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; populateInfoPanel(exact); render(); d3.select('#msg').text(''); return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; populateInfoPanel(matches[0]); render(); d3.select('#msg').text(''); return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          render();
        });
      });
      d3.select('#msg').text('Multiple matches — click a suggestion.'); return;
    } else {
      d3.select('#msg').text('Search term not found. Please try again.');
    }
  }

  function hideLoadingOverlay() { loadingOverlay.style.display = 'none'; }

  // Safety fallback: ensure overlay never permanently hangs
  setTimeout(() => {
    if (!isStable) {
      if (simulation) simulation.stop();
      isStable = true;
      hideLoadingOverlay();
      render();
    }
  }, (CONFIG.maxLoadingSeconds + 3) * 1000);

  // expose minimal debug
  window.__fdg = { nodes, links, CONFIG, render };
  </script>
</body>
</html>
